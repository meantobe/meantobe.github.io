<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>meant to be</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://meantobe.github.io/"/>
  <updated>2020-03-29T07:38:07.753Z</updated>
  <id>http://meantobe.github.io/</id>
  
  <author>
    <name>meantobe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netflix Zuul连接泄露问题</title>
    <link href="http://meantobe.github.io/2020/03/28/zuul/"/>
    <id>http://meantobe.github.io/2020/03/28/zuul/</id>
    <published>2020-03-28T04:58:57.000Z</published>
    <updated>2020-03-29T07:38:07.753Z</updated>
    
    <content type="html"><![CDATA[<p>Zuul 1.x的连接泄露问题，目前仍然存在。</p><a id="more"></a><p>2018年，公司内做微服务化改造，将单体服务拆分为多个微服务，那么就需要一个网关层做服务分发。常见的选型有Kong（Openresty）、nginx、Zuul等。出于Java和Spring Cloud技术栈的考虑，最终选择了Netflix Zuul，基于Spring Cloud Netflix开发公司内部的安全校验、路由分发等功能，版本为Spring Boot 2.0/Spring Cloud Finchley。</p><p>上线后按业务配置路由，网关正常工作。突然有一天，通过网关访问某个业务整体不可用，但访问其它服务正常。使用jstack查看，发现有许多如下线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&quot;http-nio-8080-exec-200&quot; #263 daemon prio=5 os_prio=0 tid=0x00007f109630e800 nid=0x4e30 waiting on condition [0x00007f102003f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x00000006ce533488&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at org.apache.http.pool.AbstractConnPool.getPoolEntryBlocking(AbstractConnPool.java:380)</span><br><span class="line">at org.apache.http.pool.AbstractConnPool.access$200(AbstractConnPool.java:69)</span><br><span class="line">at org.apache.http.pool.AbstractConnPool$2.get(AbstractConnPool.java:246)</span><br><span class="line">- locked &lt;0x000000075d6584e0&gt; (a org.apache.http.pool.AbstractConnPool$2)</span><br><span class="line">at org.apache.http.pool.AbstractConnPool$2.get(AbstractConnPool.java:193)</span><br><span class="line">at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.leaseConnection(PoolingHttpClientConnectionManager.java:282)</span><br><span class="line">at org.apache.http.impl.conn.PoolingHttpClientConnectionManager$1.get(PoolingHttpClientConnectionManager.java:269)</span><br><span class="line">at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:191)</span><br><span class="line">at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:185)</span><br><span class="line">at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)</span><br><span class="line">at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:111)</span><br><span class="line">at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)</span><br><span class="line">at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:118)</span><br><span class="line">    // 省略</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- &lt;0x000000075d9168c0&gt; (a java.util.concurrent.ThreadPoolExecutor$Worker)</span><br></pre></td></tr></table></figure><h1 id="第一步：连接池获取连接的超时时间问题？"><a href="#第一步：连接池获取连接的超时时间问题？" class="headerlink" title="第一步：连接池获取连接的超时时间问题？"></a>第一步：连接池获取连接的超时时间问题？</h1><p>找到获取连接的部分代码，发现这里获取连接的超时时间取自<code>RequestConfig.getConnectionRequestTimeout</code>，而<code>RequestConfig.DEFAULT</code>中，<code>connectionRequestTimeout</code>默认为-1，可能导致阻塞。</p><p>首先尝试解决获取连接的阻塞问题。由于<code>ZuulProperties.Host</code>中配置项较少，没有<code>connectRequestTimeoutMills</code>，如何配置这个参数？观察<code>ZuulProxyAutoConfiguration</code>，发现需要重写<code>CloseableHttpClient</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(&#123;SimpleHostRoutingFilter.class, CloseableHttpClient.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleHostRoutingFilter <span class="title">simpleHostRoutingFilter</span><span class="params">(ProxyRequestHelper helper, ZuulProperties zuulProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">ApacheHttpClientConnectionManagerFactory connectionManagerFactory, ApacheHttpClientFactory httpClientFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SimpleHostRoutingFilter(helper, zuulProperties, connectionManagerFactory, httpClientFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(&#123;SimpleHostRoutingFilter.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleHostRoutingFilter <span class="title">simpleHostRoutingFilter2</span><span class="params">(ProxyRequestHelper helper, ZuulProperties zuulProperties, CloseableHttpClient httpClient)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SimpleHostRoutingFilter(helper, zuulProperties, httpClient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看<code>SimpleHostRoutingFilter</code>的<code>@PostConstruct</code>，还会创建<code>connectionManagerTimer</code>定时关闭连接。因此我们也需要重写timer，配置代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulProxyConfig</span> <span class="keyword">extends</span> <span class="title">ZuulProxyAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;zuul.host.connect-request-timeout-millis&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> connectRequestTimeoutMills;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CloseableHttpClient <span class="title">httpClient</span><span class="params">(ApacheHttpClientFactory httpClientFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          ApacheHttpClientConnectionManagerFactory connectionManagerFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          ZuulProperties zuulProperties)</span> </span>&#123;</span><br><span class="line">        ZuulProperties.Host hostProperties = zuulProperties.getHost();</span><br><span class="line">        <span class="keyword">final</span> RequestConfig requestConfig = RequestConfig.custom()....build();</span><br><span class="line">        HttpClientConnectionManager connectionManager = connectionManagerFactory.newConnectionManager(...);</span><br><span class="line">        CloseableHttpClient httpClient = httpClientFactory.createBuilder().</span><br><span class="line">                setDefaultRequestConfig(requestConfig).</span><br><span class="line">                setConnectionManager(connectionManager).build();</span><br><span class="line">        Timer connectionManagerTimer = <span class="keyword">new</span> Timer(<span class="string">"SimpleHostRoutingFilter.connectionManagerTimer"</span>, <span class="keyword">true</span>);</span><br><span class="line">        connectionManagerTimer.schedule(...);</span><br><span class="line">        <span class="keyword">return</span> httpClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后部署环境，但是一段时间后问题再次出现。设置了<code>connectRequestTimeoutMills</code>后，日志中出现大量<code>com.netflix.zuul.exception.ZuulException: Timeout waiting for connection from pool</code>。因此根本原因不在获取连接超时时间，而在于为什么获取不到连接。</p><h1 id="第二步：为何拿不到连接？"><a href="#第二步：为何拿不到连接？" class="headerlink" title="第二步：为何拿不到连接？"></a>第二步：为何拿不到连接？</h1><p>第一步的改动中重写了<code>connectionManagerTimer</code>，这个timer的作用是定时回收过期线程，我们在其中增加日志定时打印各Route的连接池情况，再次出现问题时日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// leased：使用中；pending：等待中；available：空闲，max：最大连接数</span><br><span class="line">route: &#123;&#125;-&gt;http://xxx.xxx.idc:80, stats: [leased: 7; pending: 0; available: 51; max: 1000]</span><br><span class="line">route: &#123;&#125;-&gt;http://x.x.x.x:5000, stats: [leased: 0; pending: 0; available: 2; max: 1000]</span><br><span class="line">route: &#123;&#125;-&gt;http://xxx.xxx.idc:80, stats: [leased: 1000; pending: 0; available: 0; max: 1000]</span><br><span class="line">// ...</span><br><span class="line">total route stats: [leased: 1045; pending: 0; available: 59; max: 2000]</span><br></pre></td></tr></table></figure><p>可以发现多数route是正常的，但是出问题的这个服务，连接池占满了。因此原因指向了连接没有正常关闭。</p><h1 id="第三步：Zuul是如何关闭连接的？"><a href="#第三步：Zuul是如何关闭连接的？" class="headerlink" title="第三步：Zuul是如何关闭连接的？"></a>第三步：Zuul是如何关闭连接的？</h1><p>分析Zuul的代码，其核心就是三步：pre、route、post，出现异常则走error+post。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</span><br><span class="line"></span><br><span class="line">            RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">            context.setZuulEngineRan();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                preRoute();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">                error(e);</span><br><span class="line">                postRoute();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                route();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">                error(e);</span><br><span class="line">                postRoute();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                postRoute();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">                error(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            error(<span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">"UNHANDLED_EXCEPTION_"</span> + e.getClass().getName()));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            RequestContext.getCurrentContext().unset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在我们的网关中，存在两个postRoute：自定义的PostErrorHandlerFilter和Zuul的SendResponseFilter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">runFilters</span><span class="params">(String sType)</span> <span class="keyword">throws</span> Throwable </span>&#123;   <span class="comment">// sType = post</span></span><br><span class="line">    <span class="keyword">if</span> (RequestContext.getCurrentContext().debugRouting()) &#123;</span><br><span class="line">        Debug.addRoutingDebug(<span class="string">"Invoking &#123;"</span> + sType + <span class="string">"&#125; type filters"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> bResult = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// list = [PostErrorHandlerFilter(自定义), SendResponseFilter]</span></span><br><span class="line">    List&lt;ZuulFilter&gt; list = FilterLoader.getInstance().getFiltersByType(sType);</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            ZuulFilter zuulFilter = list.get(i);</span><br><span class="line">            Object result = processZuulFilter(zuulFilter);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; result <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">                bResult |= ((Boolean) result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从runFilter和ZuulServlet代码可发现，假设postRoute的filter抛出异常，就会被catch并进行error处理，然后返回。我们的项目在自定义的PostErrorHandlerFilter中非200请求统一抛出业务异常，通过Spring的<code>DefaultErrorAttributes</code>处理异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(WebRequest webRequest, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// log error and add stats.</span></span><br><span class="line">    <span class="comment">// return data</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Zuul是在SendResponseFilter中关闭连接的，因此在runFilters抛出后，打断了postRoute的流程，导致ZuulResponse的close不会被执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SendResponseFilter中关闭</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeResponse</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object zuulResponse = RequestContext.getCurrentContext().get(<span class="string">"zuulResponse"</span>);</span><br><span class="line"><span class="keyword">if</span> (zuulResponse <span class="keyword">instanceof</span> Closeable) &#123;</span><br><span class="line">((Closeable) zuulResponse).close();</span><br><span class="line">&#125;</span><br><span class="line">outStream.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">log.warn(<span class="string">"Error while sending response to client: "</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是发生连接泄露的原因。解决方式是手动关闭连接（我们是在postFilter抛出，errorFilter中关闭连接），从RequestContext中获取到ZuulResponse，执行close方法即可。</p><h1 id="总结及后续"><a href="#总结及后续" class="headerlink" title="总结及后续"></a>总结及后续</h1><p>这次故障排查几个值得关注的问题：</p><ol><li>参数配置如连接池参数等。Spring Cloud/Boot的AutoConfiguration做了很多封装，但有时也会省略一些配置（如connectionRequestTimeout），需要关注配置情况。</li><li>网关要做到路由隔离。比如Zuul不同路由可以配置不同的连接池大小，即便某个连接不可用，也不会影响其它服务。max-total-connections一定要大于max-per-route-connections。</li><li>Zuul本身的问题。从代码可以看出，除了上面所示的postRoute抛异常导致连接泄露，errorRoute抛异常同样有可能导致连接泄露，需要在代码中进行处理。考虑到Zuul 1.x不再维护，后续不建议再使用Zuul做网关。</li></ol><p>这个问题我们在Spring Cloud Netflix的GitHub中提了issue：<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/2831" target="_blank" rel="noopener">may be found a bug for httpclient connection leak #2831</a>，有国内公司也遇到过相同问题。</p><p>我们的解决方式是在postFilter和errorFilter中关闭连接。也有其它开发者提了pull request，通过注册回调的方式确保连接关闭，不再需要SendResponseFilter中关闭，详见：<a href="https://github.com/spring-cloud/spring-cloud-netflix/pull/2849" target="_blank" rel="noopener">Make sure resources are disposed at request completion #2849</a>。但是由于Zuul停止维护，这个提交没有被合并，所以该问题至今仍可复现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Zuul 1.x的连接泄露问题，目前仍然存在。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Cloud" scheme="http://meantobe.github.io/tags/Spring-Cloud/"/>
    
      <category term="Zuul" scheme="http://meantobe.github.io/tags/Zuul/"/>
    
  </entry>
  
  <entry>
    <title>loadClass导致线上服务卡顿分析</title>
    <link href="http://meantobe.github.io/2019/12/21/ClassLoader/"/>
    <id>http://meantobe.github.io/2019/12/21/ClassLoader/</id>
    <published>2019-12-21T04:15:50.000Z</published>
    <updated>2019-12-21T13:08:09.809Z</updated>
    
    <content type="html"><![CDATA[<p>一个线上服务偶尔卡顿，分析发现是loadClass导致的线程阻塞，而loadClass的原因与Feign配置有关。</p><a id="more"></a><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>最近线上的一个服务偶尔出现卡顿，表现为不特定时刻出现几分钟的异常，在这段时间内响应时间激增，如图：</p><p><img src="/images/4D8DB8BE6AA05C097954FCBFF8B43EBB.jpg" alt="IMAGE"></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先查看日志，找到慢请求，发现在服务间Feign调用后会出现一段时间的间隔。对Feign的Logger和<code>HttpMessageConverterExtractor</code>开启DEBUG日志，看到在Feign输出HTTP返回数据后到Jackson反序列化之间有几秒的间隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-12-20 10:25:55.493|*,*,*|DEBUG|feign.slf4j.Slf4jLogger:(72)|[ServiceName#methodName] &lt;--- END HTTP (1571-byte body)</span><br><span class="line">2019-12-20 10:25:56.830|*,*,*|DEBUG|org.springframework.web.client.HttpMessageConverterExtractor:(100)|Reading to [com.*.DataModel&lt;com.*.BusinessModel&gt;]</span><br></pre></td></tr></table></figure><p>这点很奇怪，在GC日志中也没有Stop-The-World出现。用jstack打印堆栈，发现有几个和Feign相关的线程处于BLOCKED状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&quot;http-nio-8080-exec-276&quot; #3021 daemon prio=5 os_prio=0 tid=0x00007fbd501a8800 nid=0xdea waiting for monitor entry [0x00007fbcbd76d000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:404)</span><br><span class="line">- waiting to lock &lt;0x00000006c6ed91d0&gt; (a java.lang.Object)</span><br><span class="line">at org.springframework.boot.loader.LaunchedURLClassLoader.loadClass(LaunchedURLClassLoader.java:93)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">at java.lang.Class.forName0(Native Method)</span><br><span class="line">at java.lang.Class.forName(Class.java:348)</span><br><span class="line">at org.springframework.util.ClassUtils.forName(ClassUtils.java:276)</span><br><span class="line">at org.springframework.http.converter.json.Jackson2ObjectMapperBuilder.registerWellKnownModulesIfAvailable(Jackson2ObjectMapperBuilder.java:797)</span><br><span class="line">at org.springframework.http.converter.json.Jackson2ObjectMapperBuilder.configure(Jackson2ObjectMapperBuilder.java:650)</span><br><span class="line">at org.springframework.http.converter.json.Jackson2ObjectMapperBuilder.build(Jackson2ObjectMapperBuilder.java:633)</span><br><span class="line">at org.springframework.http.converter.json.MappingJackson2HttpMessageConverter.&lt;init&gt;(MappingJackson2HttpMessageConverter.java:59)</span><br><span class="line">at org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter.&lt;init&gt;(AllEncompassingFormHttpMessageConverter.java:76)</span><br><span class="line">at org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport.addDefaultHttpMessageConverters(WebMvcConfigurationSupport.java:796)</span><br><span class="line">at org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport.getMessageConverters(WebMvcConfigurationSupport.java:748)</span><br><span class="line">at org.springframework.boot.autoconfigure.http.HttpMessageConverters$1.defaultMessageConverters(HttpMessageConverters.java:185)</span><br><span class="line">at org.springframework.boot.autoconfigure.http.HttpMessageConverters.getDefaultConverters(HttpMessageConverters.java:188)</span><br><span class="line">at org.springframework.boot.autoconfigure.http.HttpMessageConverters.&lt;init&gt;(HttpMessageConverters.java:105)</span><br><span class="line">at org.springframework.boot.autoconfigure.http.HttpMessageConverters.&lt;init&gt;(HttpMessageConverters.java:92)</span><br><span class="line">at org.springframework.boot.autoconfigure.http.HttpMessageConverters.&lt;init&gt;(HttpMessageConverters.java:80)</span><br><span class="line">at com.yirendai.app.fortune.support.config.FeignConfig.lambda$feignDecoder$0(FeignConfig.java:26)</span><br><span class="line">at com.yirendai.app.fortune.support.config.FeignConfig$$Lambda$536/1366741625.getObject(Unknown Source)</span><br><span class="line">at org.springframework.cloud.openfeign.support.SpringDecoder.decode(SpringDecoder.java:57)</span><br><span class="line">at org.springframework.cloud.openfeign.support.ResponseEntityDecoder.decode(ResponseEntityDecoder.java:62)</span><br><span class="line">at feign.optionals.OptionalDecoder.decode(OptionalDecoder.java:36)</span><br><span class="line">at feign.SynchronousMethodHandler.decode(SynchronousMethodHandler.java:178)</span><br><span class="line">at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:142)</span><br><span class="line">at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:80)</span><br><span class="line">at feign.ReflectiveFeign$FeignInvocationHandler.invoke(ReflectiveFeign.java:103)</span><br><span class="line">at com.sun.proxy.$Proxy178.searchUserTag(Unknown Source)</span><br></pre></td></tr></table></figure><p>查看<code>registerWellKnownModulesIfAvailable</code>处的代码，可以看到其逻辑为若classpath中有JodaTime的<code>LocalDate</code>，则加载Jackson对应的<code>JodaModule</code>（这个项目中没有引用）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ClassUtils.isPresent(<span class="string">"org.joda.time.LocalDate"</span>, <span class="keyword">this</span>.moduleClassLoader)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;? extends Module&gt; jodaModuleClass = (Class&lt;? extends Module&gt;)</span><br><span class="line">            ClassUtils.forName(<span class="string">"com.fasterxml.jackson.datatype.joda.JodaModule"</span>, <span class="keyword">this</span>.moduleClassLoader);</span><br><span class="line">        Module jodaModule = BeanUtils.instantiateClass(jodaModuleClass);</span><br><span class="line">        modulesToRegister.set(jodaModule.getTypeId(), jodaModule);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// jackson-datatype-joda not available</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LaunchedURLClassLoader.loadClass</code>将调用<code>ClassLoader.loadClass</code>来加载类，加载时需要获取锁，因此在并发环境下，可能导致线程BLOCKED状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 省略类加载代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getClassLoadingLock</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    Object lock = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelLockMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object newLock = <span class="keyword">new</span> Object();</span><br><span class="line">        lock = parallelLockMap.putIfAbsent(className, newLock);</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lock = newLock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依据以上信息，出现卡顿的流程大致如下：</p><ol><li>Feign请求时会初始化<code>MappingJackson2HttpMessageConverter</code>时尝试加载<code>JodaModule</code>。</li><li>而这个类并不在classpath中，因此无法在<code>findLoadedClass</code>中找到，每次都需要重新加载。</li><li>执行<code>loadClass</code>时需要加锁，在线上高并发场景下会导致线程BLOCKED状态。</li></ol><h1 id="解决方式一：避免ClassLoader反复加载"><a href="#解决方式一：避免ClassLoader反复加载" class="headerlink" title="解决方式一：避免ClassLoader反复加载"></a>解决方式一：避免ClassLoader反复加载</h1><p>可以看出卡顿的直接原因是反复尝试加载不在classpath中的<code>JodaModule</code>，因此将这个依赖添加到工程中。加载一次后，再次调用可以通过<code>findLoadedClass</code>获得，减少加载类导致的资源消耗，从而减少BLOCKED的出现。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-joda<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="解决方式二：避免HttpMessageConverters重复初始化"><a href="#解决方式二：避免HttpMessageConverters重复初始化" class="headerlink" title="解决方式二：避免HttpMessageConverters重复初始化"></a>解决方式二：避免HttpMessageConverters重复初始化</h1><p>但是还有另一个问题需要考虑：为什么每次请求都会初始化<code>MappingJackson2HttpMessageConverter</code>？查看<code>SpringDecoder</code>代码，可以看到每次反序列化response时会调用<code>ObjectFactory&lt;HttpMessageConverters&gt;</code>来获取converters。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(<span class="keyword">final</span> Response response, Type type)</span> <span class="keyword">throws</span> IOException, FeignException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> Class || type <span class="keyword">instanceof</span> ParameterizedType || type <span class="keyword">instanceof</span> WildcardType) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span> &#125;)</span><br><span class="line">        HttpMessageConverterExtractor&lt;?&gt; extractor = <span class="keyword">new</span> HttpMessageConverterExtractor(</span><br><span class="line">            type, <span class="keyword">this</span>.messageConverters.getObject().getConverters());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> extractor.extractData(<span class="keyword">new</span> FeignResponseAdapter(response));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> DecodeException(response.status(),</span><br><span class="line">        <span class="string">"type is not an instance of Class or ParameterizedType: "</span> + type,</span><br><span class="line">        response.request());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在FeignConfig中配置的这个ObjectFactory的实现是new一个<code>HttpMessageConverters</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Decoder <span class="title">feignDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper()</span><br><span class="line">            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    HttpMessageConverter jacksonConverter = <span class="keyword">new</span> MappingJackson2HttpMessageConverter(mapper);</span><br><span class="line">    ObjectFactory&lt;HttpMessageConverters&gt; objectFactory = () -&gt; <span class="keyword">new</span> HttpMessageConverters(jacksonConverter);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OptionalDecoder(<span class="keyword">new</span> ResponseEntityDecoder(<span class="keyword">new</span> SpringDecoder(objectFactory)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HttpMessageConverters</code>的构造方法会默认执行<code>getDefaultConverters</code>。其逻辑可查看<code>WebMvcConfigurationSupport</code>代码，其中<code>AllEncompassingFormHttpMessageConverter</code>的构造函数会创建<code>MappingJackson2HttpMessageConverter</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HttpMessageConverters</span><span class="params">(HttpMessageConverter&lt;?&gt;... additionalConverters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Arrays.asList(additionalConverters));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HttpMessageConverters</span><span class="params">(Collection&lt;HttpMessageConverter&lt;?&gt;&gt; additionalConverters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">true</span>, additionalConverters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HttpMessageConverters</span><span class="params">(<span class="keyword">boolean</span> addDefaultConverters, Collection&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">    List&lt;HttpMessageConverter&lt;?&gt;&gt; combined = getCombinedConverters(converters,</span><br><span class="line">        addDefaultConverters ? getDefaultConverters() : Collections.emptyList());</span><br><span class="line">    combined = postProcessConverters(combined);</span><br><span class="line">    <span class="keyword">this</span>.converters = Collections.unmodifiableList(combined);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是每一个请求都会初始化<code>MappingJackson2HttpMessageConverter</code>并触发<code>loadClass</code>的原因，因此每一个Feign请求的开销都很大。由于我们只需要使用自定义的<code>MappingJackson2HttpMessageConverter</code>来执行反序列化，可以想办法避免执行<code>getDefaultConverters</code>：</p><p>第一种方法是指定<code>HttpMessageConverters</code>的构造方法参数<code>addDefaultConverters</code>为false：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectFactory&lt;HttpMessageConverters&gt; objectFactory = () -&gt; <span class="keyword">new</span> HttpMessageConverters(<span class="keyword">false</span>, Collections.singletonList(jacksonConverter));</span><br></pre></td></tr></table></figure><p>第二种方法则是使用Feign的<code>JacksonDecoder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Decoder <span class="title">feignDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper()</span><br><span class="line">            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JacksonDecoder(mapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个线上服务偶尔卡顿，分析发现是loadClass导致的线程阻塞，而loadClass的原因与Feign配置有关。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://meantobe.github.io/tags/Java/"/>
    
      <category term="Feign" scheme="http://meantobe.github.io/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>Hashids原理及简略实现</title>
    <link href="http://meantobe.github.io/2019/12/11/hashids/"/>
    <id>http://meantobe.github.io/2019/12/11/hashids/</id>
    <published>2019-12-10T16:21:08.000Z</published>
    <updated>2020-04-02T18:14:26.129Z</updated>
    
    <content type="html"><![CDATA[<p>Hashids的原理及简略实现</p><a id="more"></a><p>Hashids是一个将数字转化为长度较短、唯一且不连续的值的库。特点是：</p><ol><li>对非负整数都可以生成唯一短id；</li><li>可以设置不同的盐，具有保密性；</li><li>递增的输入产生的输出无法预测；</li><li>代码较短，且不依赖于第三方库。</li></ol><p>那么Hashids的原理是什么？Hashids的机制类似于十进制数字转换为16进制的映射，但是做了一点改动：</p><ol><li>没有使用16进制，而是62进制（26个字母大小写+10个数字）；</li><li>这个「62进制」的映射通过加盐而做了扰动。</li></ol><p>首先我们可以实现第一步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashids</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String alphabet = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hash</span><span class="params">(<span class="keyword">long</span> input, String alphabet)</span> </span>&#123;</span><br><span class="line">        StringBuilder hash = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> alphabetLen = alphabet.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index = (<span class="keyword">int</span>) (input % alphabetLen);</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; alphabet.length()) &#123;</span><br><span class="line">                hash.insert(<span class="number">0</span>, alphabet.charAt(index));</span><br><span class="line">            &#125;</span><br><span class="line">            input /= alphabetLen;</span><br><span class="line">        &#125; <span class="keyword">while</span> (input &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hash.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅有映射显然不足以提供安全性，因此还需要加以扰动。对映射表洗牌可以改变输出值，那么我们如何能够可重放的洗牌，使得每次产生相同的结果呢？Hashids使用了Fisher–Yates洗牌算法的变种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fisher–Yates洗牌算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">shuffle</span><span class="params">(String alphabet)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] shuffle = alphabet.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = shuffle.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="keyword">new</span> Random().nextInt(i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">char</span> tmp = shuffle[i];</span><br><span class="line">        shuffle[i] = shuffle[j];</span><br><span class="line">        shuffle[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(shuffle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hashids使用Fisher–Yates洗牌算法基本思路：每次选择一个数字交换到剩下的数字的最后一位。但每次选择数字是通过盐来选择的，将原算法改进为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">consistentShuffle</span><span class="params">(String alphabet, String salt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] shuffle = alphabet.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = shuffle.length - <span class="number">1</span>, v = <span class="number">0</span>, p = <span class="number">0</span>; i &gt;= <span class="number">1</span>; i--, v++) &#123;</span><br><span class="line">        v = v % salt.length();</span><br><span class="line">        <span class="keyword">int</span> integer = salt.charAt(v);</span><br><span class="line">        p += integer;</span><br><span class="line">        <span class="keyword">int</span> j = (integer + v + p) % i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> tmp = shuffle[i];</span><br><span class="line">        shuffle[i] = shuffle[j];</span><br><span class="line">        shuffle[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(shuffle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">salt=sheep -&gt; alphabet=K1RNlAYFWTeX8DEL720Iia9bcfjnBPm4sSCopgUuqz6rQH5xhtOv3ZMGJwdkyV</span><br><span class="line">salt=sleep -&gt; alphabet=zROjCepudWwIQYxfKc5vTLmZ9qXEBy4lkns706r1PaMH8ibJtF2D3gUSNAhoGV</span><br></pre></td></tr></table></figure><p>Hashids也可以将多个数字生成为1个id，方法是从映射表中选取一些字符作为分隔符。这些分隔符不用于编码，只用于分隔其它编码后的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String seps = <span class="string">"cfhistuCFHISTU"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">encode</span><span class="params">(<span class="keyword">long</span>[] numbers, String alphabet, String salt)</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> sepsIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> num = numbers[i];</span><br><span class="line"></span><br><span class="line">        alphabet = consistentShuffle(alphabet, salt);</span><br><span class="line">        String last = hash(num, alphabet);</span><br><span class="line"></span><br><span class="line">        result.append(last);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; numbers.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                num %= (last.charAt(<span class="number">0</span>) + i);</span><br><span class="line">                sepsIndex = (<span class="keyword">int</span>) (num % seps.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sepsIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result.append(seps.charAt(sepsIndex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1           -&gt; R</span><br><span class="line">1,2         -&gt; RfP</span><br><span class="line">1,2,3       -&gt; RfPht</span><br><span class="line">1,2,3,4     -&gt; RfPhti4</span><br><span class="line">1,2,3,4,5   -&gt; RfPhti4s4</span><br><span class="line">1,2,3,4,5,6 -&gt; RfPhti4s4tE</span><br></pre></td></tr></table></figure><p>参考资料：</p><ol><li><a href="https://hashids.org/" target="_blank" rel="noopener">Hashids - generate short unique ids from integers</a></li><li><a href="https://github.com/10cella/hashids-java" target="_blank" rel="noopener">10cella/hashids-java: Hashids algorithm v1.0.0 implementation in Java</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hashids的原理及简略实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://meantobe.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud OpenFeign的若干问题与近期更新</title>
    <link href="http://meantobe.github.io/2019/11/09/feign/"/>
    <id>http://meantobe.github.io/2019/11/09/feign/</id>
    <published>2019-11-09T09:19:35.000Z</published>
    <updated>2020-04-06T01:28:53.875Z</updated>
    
    <content type="html"><![CDATA[<p>一个rpc在2019年才解决url encode、参数继承、request model等问题。</p><a id="more"></a><h1 id="Feign与OpenFeign"><a href="#Feign与OpenFeign" class="headerlink" title="Feign与OpenFeign"></a>Feign与OpenFeign</h1><p><a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">Feign</a>是Netflix开源的一个声明式HTTP客户端，9.0起迁移至OpenFeign，简要的历史可见 <a href="https://github.com/OpenFeign/feign/issues/373" target="_blank" rel="noopener">Move to a new org</a> 。</p><p>Spring Cloud中和Feign相关的代码原在Spring Cloud Netflix项目内。在Finchley.M7（Spring Cloud Netflix 2.0.0.M7）版本中，Feign相关的代码迁移到一个新项目Spring Cloud OpenFeign内。即<code>org.springframework.cloud.netflix.feign</code>相关代码改为<code>org.springframework.cloud.openfeign</code>。</p><p>然而作为一个声明式客户端，Feign居然在近期的几个版本才解决一些基础性问题（model传参、丢model父类参数、url encode等等），很容易踩坑。我在项目中遇到过的问题如下：</p><ol><li>Spring Cloud OpenFeign自Greenwich起支持query map声明为model。</li><li>Feign 10.2.0（Spring Cloud Greenwich.SR2）修复+号在query string中未encode问题。</li><li>Feign 10.3.0（Spring Cloud Greenwich.SR4）支持model继承。</li><li>Spring Cloud Alibaba 2.1.0.RELEASE修复Feign接口继承时产生的空指针。</li></ol><h1 id="Spring-OpenFeign的若干问题"><a href="#Spring-OpenFeign的若干问题" class="headerlink" title="Spring OpenFeign的若干问题"></a>Spring OpenFeign的若干问题</h1><h2 id="Model作为Query-Map的支持"><a href="#Model作为Query-Map的支持" class="headerlink" title="Model作为Query Map的支持"></a>Model作为Query Map的支持</h2><p>Feign支持Model转换为QueryMap（9.7.0之后可以设置encode: <a href="https://github.com/OpenFeign/feign/pull/667" target="_blank" rel="noopener">https://github.com/OpenFeign/feign/pull/667</a> ），但是Feign的<code>@QueryMap</code>注解由于缺少<code>value</code>字段，在Spring Cloud OpenFeign中并不支持。</p><p>Spring Cloud OpenFeign的2.1.x版本中增加<code>@SpringQueryMap</code>注解，从此支持将Model转换为QueryMap，但是如果Model中有serialVersionUID字段，也会被放入请求参数中。</p><h2 id="Feign对Query-String特殊字符的encode"><a href="#Feign对Query-String特殊字符的encode" class="headerlink" title="Feign对Query String特殊字符的encode"></a>Feign对Query String特殊字符的encode</h2><p>Feign 10.x引入一个新问题：对query string未将+号转换为%2B，在10.2.0版本中修复（<a href="https://github.com/OpenFeign/feign/pull/882" target="_blank" rel="noopener">Adding URI segment specific encoding</a>）。</p><p>Spring Cloud OpenFeign 2.1.2版本升级到Feign 10.2.3，修复该问题。</p><h2 id="Feign使用model时无法生成父类的字段参数"><a href="#Feign使用model时无法生成父类的字段参数" class="headerlink" title="Feign使用model时无法生成父类的字段参数"></a>Feign使用model时无法生成父类的字段参数</h2><p>虽然有了<code>@SpringQueryMap</code>，但如果使用了含有继承关系的model，如<code>XXXReq extends BaseReq</code>，Feign只能将<code>XXXReq</code>中参数放在url中，<code>BaseReq</code>中的内容丢失。在Feign 10.3.0中解决，PR见<a href="https://github.com/OpenFeign/feign/pull/960" target="_blank" rel="noopener">This pr resolves QueryMap inheritance issue #927</a>。</p><p>Spring Cloud OpenFeign 2.1.4版本升级到Feign 10.4.0，修复该问题。</p><h2 id="在继承Feign接口时使用Sentinel出现空指针"><a href="#在继承Feign接口时使用Sentinel出现空指针" class="headerlink" title="在继承Feign接口时使用Sentinel出现空指针"></a>在继承Feign接口时使用Sentinel出现空指针</h2><p>Spring Cloud Alibaba的一个问题，详情见 <a href="https://github.com/alibaba/spring-cloud-alibaba/issues/626" target="_blank" rel="noopener">Feign with Sentinel in Inheritance interface will throw NPE</a>，在新版本中修复了这个问题。</p><p>Spring Cloud发布列车和OpenFeign及Feign的版本关系：</p><table><thead><tr><th>Spring Cloud版本</th><th>OpenFeign版本</th><th>Feign版本</th></tr></thead><tbody><tr><td>Greenwich.RELEASE</td><td>2.1.0.RELEASE</td><td>9.5.1</td></tr><tr><td>Greenwich.SR1</td><td>2.1.1.RELEASE</td><td>9.5.1</td></tr><tr><td>Greenwich.SR2</td><td>2.1.2.RELEASE</td><td>10.2.3</td></tr><tr><td>Greenwich.SR3</td><td>2.1.3.RELEASE</td><td>10.2.3</td></tr><tr><td>Greenwich.SR4</td><td>2.1.4.RELEASE</td><td>10.4.0</td></tr></tbody></table><p>总结：使用Spring Cloud Greenwich.SR4可以避免上面各已知问题，Spring Cloud Alibaba的问题也在最新版（2.1.0.RELEASE）解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个rpc在2019年才解决url encode、参数继承、request model等问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Feign" scheme="http://meantobe.github.io/tags/Feign/"/>
    
      <category term="Spring Cloud" scheme="http://meantobe.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWriteArrayList的subList需要注意的点</title>
    <link href="http://meantobe.github.io/2019/08/20/sublist/"/>
    <id>http://meantobe.github.io/2019/08/20/sublist/</id>
    <published>2019-08-20T09:49:09.000Z</published>
    <updated>2020-04-02T18:22:58.479Z</updated>
    
    <content type="html"><![CDATA[<ol><li>CopyOnWriteArrayList的subList仅是原始列表的视图，原始列表修改后操作subList会出现ConcurrentModificationException。</li><li>对CopyOnWriteArrayList的subList任何操作都需要获取读锁，更好的方式是使用不可变对象。</li></ol><a id="more"></a><p>Review代码时发现同事写了一段加载缓存并从缓存中获取部分数据的逻辑，使用CopyOnWriteArrayList实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> CopyOnWriteArrayList&lt;Info&gt;&gt; FULL_LIST = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;Info&gt; <span class="title">getList</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> FULL_LIST.subList(start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新缓存时对CopyOnWriteArrayList进行操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some logic</span></span><br><span class="line">    FULL_LIST.add(...);</span><br><span class="line">    FULL_LIST.remove(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这几个方法（<code>add</code>, <code>remove</code>, <code>subList</code>）都会获取<code>ReentrantLock</code>，看起来似乎没什么问题。但是写一个例子就会发现对subList操作时可能会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CWALTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Integer&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; sub = list.subList(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        sub.get(<span class="number">0</span>); <span class="comment">// will throws ConcurrentModificationException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常信息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.util.ConcurrentModificationException</span><br><span class="line">at java.util.concurrent.CopyOnWriteArrayList$COWSubList.checkForComodification(CopyOnWriteArrayList.java:<span class="number">1277</span>)</span><br><span class="line">at java.util.concurrent.CopyOnWriteArrayList$COWSubList.size(CopyOnWriteArrayList.java:<span class="number">1317</span>)</span><br></pre></td></tr></table></figure><p>查看CopyOnWriteArrayList中subList方法的代码，可以看到subList返回的是一个静态内部类COWSubList对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = l.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span> || toIndex &gt; size || fromIndex &gt; toIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> COWSubList&lt;E&gt;(l, fromIndex + offset, toIndex + offset);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而COWSubList中有一个expectedArray属性，指向是对象创建时CopyOnWriteArrayList的array对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">COWSubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; l;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Object[] expectedArray;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// only call this holding l's lock</span></span><br><span class="line">    COWSubList(CopyOnWriteArrayList&lt;E&gt; list, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        l = list;</span><br><span class="line">        expectedArray = l.getArray();</span><br><span class="line">        offset = fromIndex;</span><br><span class="line">        size = toIndex - fromIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在之后对子列表操作时，会先调用<code>checkForComodification</code>方法，若原CopyOnWriteArrayList被修改，则抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only call this holding l's lock</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l.getArray() != expectedArray)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此取subList时需要考虑线程安全问题，更好的方式是使用不可变列表（例如Guava的ImmutableList），避免对原始列表的更新导致子列表抛出异常，更新缓存时指向新的ImmutableList对象即可，相关代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> ImmutableList&lt;Info&gt;&gt; FULL_LIST = ImmutableList.of();</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;Info&gt; <span class="title">getList</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> FULL_LIST.subList(start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some logic</span></span><br><span class="line">    FULL_LIST = ImmutableList.copyOf(newList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImmutableList的subList方法取的的是一个子类SubList，和COWSubList类似，仅是一个视图。但由于列表不可变，仅需要检查索引未越界即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">ImmutableList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    SubList(<span class="keyword">int</span> offset, <span class="keyword">int</span> length) &#123;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此外，不可变列表无需加锁，避免了COWSubList中操作都需要获得锁的不便。测试对于有大量读线程的情况下，ImmutableList读取效率远高于COWSubList。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;CopyOnWriteArrayList的subList仅是原始列表的视图，原始列表修改后操作subList会出现ConcurrentModificationException。&lt;/li&gt;
&lt;li&gt;对CopyOnWriteArrayList的subList任何操作都需要获取读锁，更好的方式是使用不可变对象。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://meantobe.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>多数据源的高效归并分页排序</title>
    <link href="http://meantobe.github.io/2019/08/15/merge_and_sort/"/>
    <id>http://meantobe.github.io/2019/08/15/merge_and_sort/</id>
    <published>2019-08-15T04:50:00.000Z</published>
    <updated>2019-11-19T07:17:49.457Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：</p><ol><li>通过传递排序字段进行分页的策略及不足。</li><li>通过Redis Sorted Set进行分页的策略及问题。</li><li>通过覆盖索引分页后取数的策略。</li></ol><a id="more"></a><p>我们的用户持仓接口原本很简单，从一张单独的表A中做分页查询，按时间倒序排列，接口形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/user/holding/list?userId=&#123;&#125;&amp;pageNo=&#123;&#125;&amp;rows=&#123;&#125;</span><br></pre></td></tr></table></figure><p>查询数据库时需要几个连表操作，较为复杂，不过能够满足分页查询的效率。</p><h2 id="多数据源归并分页，第一个实现（有bug）"><a href="#多数据源归并分页，第一个实现（有bug）" class="headerlink" title="多数据源归并分页，第一个实现（有bug）"></a>多数据源归并分页，第一个实现（有bug）</h2><p>产品提了一个需求，想要把另一类用户持仓放在一起展示。从表B中取出数据，排序规则相同，按时间倒序。</p><p>首先想到的方案是通过时间戳控制分页来归并数据。从A、B中各取N条数据，合并后取时间戳最大的前N条，核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Resp&gt; <span class="title">queryPagedListByLimitTime</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">int</span> rows, <span class="keyword">long</span> limitTime)</span> </span>&#123;</span><br><span class="line">    List&lt;Resp&gt; totalList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    totalList.addAll(aService.getListByLimitTime(userId, rows, limitTime));</span><br><span class="line">    totalList.addAll(bService.getListByLimitTime(userId, rows, limitTime));</span><br><span class="line">    <span class="keyword">return</span> totalList.stream()</span><br><span class="line">                    .sorted(Comparator.comparing(Resp::getCreateTime).reversed())</span><br><span class="line">                    .limit(rows)</span><br><span class="line">                    .map(<span class="comment">/* do business */</span>)</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别查询A、B服务时的SQL如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> xxx,xxx,xxx,xxx</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">WHERE</span> userId = <span class="comment">#&#123;userId&#125; AND createTime &lt; #&#123;limitTime&#125;</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="comment">#&#123;rows&#125;</span></span><br></pre></td></tr></table></figure><p>翻页时，需要传递上一页中最后一条的时间戳，第一次请求时传递当前时间戳。因此接口设计变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/user/holding/list?userId=&#123;&#125;&amp;rows=&#123;&#125;&amp;limitTime=&#123;&#125;</span><br></pre></td></tr></table></figure><p>这个实现简单而高效，但是上线后发现有丢数据的情况。因为系统有批量下单功能，导致许多持仓数据的createTime字段毫秒值都相同。而查询时传入当页的最后一条时间戳，因此下一页中按小于此时间戳查询，就丢失了跨页的数据。</p><h2 id="Redis归并排序分页，第二个实现"><a href="#Redis归并排序分页，第二个实现" class="headerlink" title="Redis归并排序分页，第二个实现"></a>Redis归并排序分页，第二个实现</h2><p>使用时间戳排序有分页的缺陷，因此接口API需要变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/user/holding/list?userId=&#123;&#125;&amp;pageNo=&#123;&#125;&amp;rows=&#123;&#125;</span><br></pre></td></tr></table></figure><p>首先查询逻辑不变，但是现在需要尽可能查出所有数据完成排序。因此将用户数据缓存到Redis的ZSET中，score是用于排序的字段（时间戳）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putUserDataIntoRedis</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</span><br><span class="line">    String userSetKey = RedisConstants.HOLDING + <span class="string">"userId:"</span> + userId;</span><br><span class="line">    List&lt;Resp&gt; totalList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    totalList.add(aService.getAllList(userId));</span><br><span class="line">    totalList.add(bService.getAllList(userId));</span><br><span class="line">    <span class="keyword">if</span> (!totalList.isEmpty()) &#123;</span><br><span class="line">          Set&lt;ZSetOperations.TypedTuple&lt;Resp&gt;&gt; sets = totalList.stream()</span><br><span class="line">                  .map(resp -&gt; (ZSetOperations.TypedTuple&lt;Resp&gt;) <span class="keyword">new</span> DefaultTypedTuple&lt;&gt;(resp, (<span class="keyword">double</span>) resp.getCreateTime()))</span><br><span class="line">                  .collect(Collectors.toSet());</span><br><span class="line">          BoundZSetOperations&lt;String, String&gt; boundZSetOperations = redisTemplate.boundZSetOps(userSetKey);</span><br><span class="line">          boundZSetOperations.add(sets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取数据时通过Redis的ZSET取数据，以实现翻页时的高效。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Resp&gt; <span class="title">queryPagedListFromRedis</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">int</span> rows, <span class="keyword">int</span> pageNo)</span> </span>&#123;</span><br><span class="line">    String userSetKey = RedisConstants.HOLDING + <span class="string">"userId:"</span> + userId;</span><br><span class="line">    BoundZSetOperations&lt;String, Resp&gt; boundZSetOperations = redisTemplate.boundZSetOps(userSetKey);</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;Resp&gt;&gt; totalRemainSet = boundZSetOperations.reverseRange(pageNo * rows, (pageNo + <span class="number">1</span>) * rows);</span><br><span class="line">    <span class="keyword">return</span> totalRemainSet.stream()</span><br><span class="line">              .map(ZSetOperations.TypedTuple::getValue)</span><br><span class="line">              .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于此时调用旧版本接口的客户端已经发版，如何兼容处理跨页的数据丢失问题？客户端表示可以每页返回超过请求的rows数量，那么我们可以考虑在一页中把下一页中相同时间戳的数据一并返回，以兼容旧版本客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取小于入参limitTime的所有数据（需要过滤掉等于limitTime的数据）</span></span><br><span class="line">Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; totalRemainSet = boundZSetOperations.reverseRangeByScoreWithScores(<span class="number">0</span>, limitTime-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Resp&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">double</span> lastTimeStamp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;Resp&gt; val : totalRemainSet) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(val.getScore() - lastTimeStamp) &gt;= <span class="number">1</span> &amp;&amp; result.size() &gt;= rows) &#123;</span><br><span class="line">        <span class="comment">// 时间戳不同，且超过每页条数，退出并返回当前数据</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 时间戳相同 或 没有超过每页条数，则加入</span></span><br><span class="line">    result.add(val.getValue());</span><br><span class="line">    lastTimeStamp = val.getScore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现存在几个问题：</p><ol><li>需要在用户首次进入时获取全量数据，效率无法保证。</li><li>数据放在缓存中，需要更新维护，增加了系统复杂度。</li><li>（对于旧客户端的兼容）破坏了接口的约定，请求传入rows=15返回却可能是rows=200。</li></ol><p>测试对于持仓较多的用户，这个方案性能过低，因此最终未能上线。</p><h2 id="覆盖索引，第三个实现"><a href="#覆盖索引，第三个实现" class="headerlink" title="覆盖索引，第三个实现"></a>覆盖索引，第三个实现</h2><p>第二个方案虽然未上线，但是思路有可取之处。总结上面两个方案可知：</p><ol><li>由于时间戳有重复，因此以limitTime做入参是不可行的，需要分页方式查询。</li><li>由于数据源不同，因此需要以相同排序条件查出后归并。但是若通过标记id等辅助分页字段方式分页，则需要增加接口字段，增加复杂度。</li><li>全量数据归并后排序就不需要辅助字段，可保持接口参数不变，但是需要高效的查询全量数据方式。</li></ol><p>由于排序时仅需要根据createTime排序，因此获取全量数据可改为仅获取id和createTime两个字段，排序后再通过id查询信息。</p><p>增加查询这两个字段的方法，结果包装为RespIds对象。数据库建立userId和createTime两个字段的索引，使得该查询可以通过覆盖索引直接返回，无须回表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, createTime</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">WHERE</span> userId = <span class="comment">#&#123;userId&#125;</span></span><br></pre></td></tr></table></figure><p>改造查询列表接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Resp&gt; <span class="title">queryPagedList</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">int</span> rows, <span class="keyword">int</span> pageNo)</span> </span>&#123;</span><br><span class="line">    List&lt;RespIds&gt; totalList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    totalList.addAll(aService.getAllIds(userId));</span><br><span class="line">    totalList.addAll(bService.getAllIds(userId));</span><br><span class="line"></span><br><span class="line">    List&lt;RespIds&gt; curPageIds = totalList.stream()</span><br><span class="line">                        .sorted(Comparator.comparing(RespIds::getCreateTime).reversed())</span><br><span class="line">                        .skip(pageNo * rows)</span><br><span class="line">                        .limit(rows)</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">    Set&lt;Long&gt; aIds = curPageIds.stream().filter(RespIds::isA)</span><br><span class="line">                        .map(RespIds::getId)</span><br><span class="line">                        .collect(Collectors.toSet());</span><br><span class="line">    Set&lt;Long&gt; bIds = curPageIds.stream().filter(RespIds::isB)</span><br><span class="line">                        .map(RespIds::getId)</span><br><span class="line">                        .collect(Collectors.toSet());</span><br><span class="line">    Map&lt;Long, Resp&gt; respSet = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (aIds.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          respSet.putAll(aService.queryDetails(aIds));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bIds.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          respSet.putAll(bService.queryDetails(bIds));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curPageIds.stream()</span><br><span class="line">                     .map(id -&gt; respSet.getOrDefault(id.getId(), <span class="keyword">null</span>))</span><br><span class="line">                     .map(<span class="comment">/* do business */</span>)</span><br><span class="line">                     .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取信息时queryDetails通过主键索引id查询，也可以保证效率。</p><p>对客户端接口参数中的limitTime改为pageNo，对于旧版本客户端limitTime稍作处理即可实现兼容。在此不赘述。</p><p>方案三上线后和方案一效率基本相同，但是避免了方案一的遗漏数据的问题。且对于单个用户具有大量数据的情况下，方案三表现优于方案一。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过传递排序字段进行分页的策略及不足。&lt;/li&gt;
&lt;li&gt;通过Redis Sorted Set进行分页的策略及问题。&lt;/li&gt;
&lt;li&gt;通过覆盖索引分页后取数的策略。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="http://meantobe.github.io/tags/SQL/"/>
    
      <category term="Redis" scheme="http://meantobe.github.io/tags/Redis/"/>
    
      <category term="API Design" scheme="http://meantobe.github.io/tags/API-Design/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat新版本Host Name Validate问题</title>
    <link href="http://meantobe.github.io/2019/05/20/tomcat/"/>
    <id>http://meantobe.github.io/2019/05/20/tomcat/</id>
    <published>2019-05-20T03:48:00.000Z</published>
    <updated>2019-08-23T03:48:21.440Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：</p><ol><li>Tomcat不同版本对HTTP请求中valid characters的配置。</li><li>Tomcat新版本中Host Name Validate的开启。</li><li>Spring Boot和Tomcat版本间的对应关系。</li></ol><a id="more"></a><p>最近将一个项目由Spring Cloud Finchely.M5升级到Greenwich.SR1，在灰度环境正常，而线上则在网关层报400 Bad Request。</p><p>首先怀疑是特殊字符的问题，因为之前也遇到过这个问题。Tomcat 7.0.73中有一处改动使得带有{}|等符号的查询会返回400。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add additional checks for valid characters to the HTTP request line parsing so invalid request lines are rejected sooner.</span><br></pre></td></tr></table></figure><p>在Tomcat 7.0.76中，添加了配置项。可以配置Tomcat行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tomcat.util.http.parser.HttpParser.requestTargetAllow=</span><br></pre></td></tr></table></figure><p>之前该项目也是通过这个配置来避免400，现在为什么不行了呢？查询Tomcat文档，该配置在<a href="https://tomcat.apache.org/tomcat-8.5-doc/config/systemprops.html" target="_blank" rel="noopener">Tomcat 8</a>中已标记为deprecated，在<a href="https://tomcat.apache.org/tomcat-9.0-doc/config/systemprops.html" target="_blank" rel="noopener">Tomcat 9</a>中移除，使用<code>relaxedPathChars</code>和<code>relaxedQueryChars</code>替代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This system property is deprecated. Use the relaxedPathChars and relaxedQueryChars attributes of the Connector instead. These attributes permit a wider range of characters to be configured as valid.</span><br></pre></td></tr></table></figure><p>Spring Boot 2.0.x到2.1.x的升级中，Tomcat版本由8.5升级至9.0，因此需要配置relaxedQueryChars和relaxedPathChars。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; <span class="title">containerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedTomcatCustomizer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedTomcatCustomizer</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">TomcatServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(TomcatServletWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">        factory.addConnectorCustomizers((TomcatConnectorCustomizer) connector -&gt; &#123;</span><br><span class="line">            connector.setAttribute(<span class="string">"relaxedPathChars"</span>, <span class="string">"\"&lt;&gt;[\\]^`&#123;|&#125;"</span>);</span><br><span class="line">            connector.setAttribute(<span class="string">"relaxedQueryChars"</span>, <span class="string">"\"&lt;&gt;[\\]^`&#123;|&#125;"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但更新后依然报400。查看服务日志，找到一段异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http-nio-8080-exec-1 | INFO  | org.apache.coyote.http11.Http11Processor(175) KEY: | Error parsing HTTP request header</span><br><span class="line"> Note: further occurrences of HTTP request parsing errors will be logged at DEBUG level.</span><br><span class="line">java.lang.IllegalArgumentException: Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986</span><br><span class="line">at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:467)</span><br><span class="line">at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:294)</span><br><span class="line">at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)</span><br><span class="line">at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834)</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415)</span><br><span class="line">at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><p>似乎是请求处理有问题，开启DEBUG日志，异常如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http-nio-8080-exec-5 | DEBUG | org.apache.coyote.http11.Http11Processor(175) KEY: | The host [finance_pools] is not valid</span><br><span class="line">java.lang.IllegalArgumentException: The character [_] is never valid in a domain name.</span><br><span class="line">at org.apache.tomcat.util.http.parser.HttpParser$DomainParseState.next(HttpParser.java:926)</span><br><span class="line">at org.apache.tomcat.util.http.parser.HttpParser.readHostDomainName(HttpParser.java:822)</span><br><span class="line">at org.apache.tomcat.util.http.parser.Host.parse(Host.java:71)</span><br><span class="line">at org.apache.tomcat.util.http.parser.Host.parse(Host.java:45)</span><br><span class="line">at org.apache.coyote.AbstractProcessor.parseHost(AbstractProcessor.java:288)</span><br><span class="line">at org.apache.coyote.http11.Http11Processor.prepareRequest(Http11Processor.java:809)</span><br><span class="line">at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:384)</span><br><span class="line">at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)</span><br><span class="line">at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834)</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415)</span><br><span class="line">at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure><p>原来是Tomcat 8.5.31/9.0.5后开启强制域名验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enable strict validation of the provided host name and port for all connectors. Requests with invalid host names and/or ports will be rejected with a 400 response. (markt)</span><br></pre></td></tr></table></figure><p>而运维在nginx中配置的upstream名称为<code>finance_pools</code>，因此被tomcat拦截。</p><p>对比Spring Cloud不同版本中不同的Tomcat版本。可见升级前版本不需严格校验，升级后版本需要。因此导致400问题。</p><table><thead><tr><th>Spring Cloud版本</th><th>Spring Boot版本</th><th>Tomcat版本</th></tr></thead><tbody><tr><td>Finchley.M5</td><td>2.0.0.M7</td><td>8.5.23</td></tr><tr><td>Greenwich.SR1</td><td>2.1.3.RELEASE</td><td>9.0.16</td></tr></tbody></table><p>联系运维将upstream名称中的下划线去掉后正常。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>Tomcat 8 -&gt; 9时，需要将<code>tomcat.util.http.parser.HttpParser.requestTargetAllow</code>替换为relaxedQueryChars和relaxedPathChars配置。</li><li>Tomcat新版本中host name validate为强制校验，因此无法使用带有下划线的host name。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Tomcat不同版本对HTTP请求中valid characters的配置。&lt;/li&gt;
&lt;li&gt;Tomcat新版本中Host Name Validate的开启。&lt;/li&gt;
&lt;li&gt;Spring Boot和Tomcat版本间的对应关系。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Tomcat" scheme="http://meantobe.github.io/tags/Tomcat/"/>
    
      <category term="Spring Boot" scheme="http://meantobe.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
</feed>
