<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>meant to be</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://meantobe.github.io/"/>
  <updated>2019-08-23T03:36:10.263Z</updated>
  <id>http://meantobe.github.io/</id>
  
  <author>
    <name>meantobe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CopyOnWriteArrayList的subList问题</title>
    <link href="http://meantobe.github.io/2019/08/20/sublist/"/>
    <id>http://meantobe.github.io/2019/08/20/sublist/</id>
    <published>2019-08-20T09:49:09.000Z</published>
    <updated>2019-08-23T03:36:10.263Z</updated>
    
    <content type="html"><![CDATA[<p>Review代码时发现同事写了一段加载缓存并从缓存中获取部分数据的逻辑，使用CopyOnWriteArrayList实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> CopyOnWriteArrayList&lt;Info&gt;&gt; FULL_LIST = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;Info&gt; <span class="title">getList</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> FULL_LIST.subList(start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新缓存时对CopyOnWriteArrayList进行操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some logic</span></span><br><span class="line">    FULL_LIST.add(...);</span><br><span class="line">    FULL_LIST.remove(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这几个方法（<code>add</code>, <code>remove</code>, <code>subList</code>）都会获取<code>ReentrantLock</code>，看起来似乎没什么问题。但是写一个例子就会发现对subList操作时可能会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CWALTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Integer&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; sub = list.subList(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        sub.get(<span class="number">0</span>); <span class="comment">// will throws ConcurrentModificationException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常信息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.util.ConcurrentModificationException</span><br><span class="line">at java.util.concurrent.CopyOnWriteArrayList$COWSubList.checkForComodification(CopyOnWriteArrayList.java:<span class="number">1277</span>)</span><br><span class="line">at java.util.concurrent.CopyOnWriteArrayList$COWSubList.size(CopyOnWriteArrayList.java:<span class="number">1317</span>)</span><br></pre></td></tr></table></figure><p>查看CopyOnWriteArrayList中subList方法的代码，可以看到subList返回的是一个静态内部类COWSubList对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = l.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span> || toIndex &gt; size || fromIndex &gt; toIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> COWSubList&lt;E&gt;(l, fromIndex + offset, toIndex + offset);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而COWSubList中有一个expectedArray属性，指向是对象创建时CopyOnWriteArrayList的array对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">COWSubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; l;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Object[] expectedArray;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// only call this holding l's lock</span></span><br><span class="line">    COWSubList(CopyOnWriteArrayList&lt;E&gt; list, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        l = list;</span><br><span class="line">        expectedArray = l.getArray();</span><br><span class="line">        offset = fromIndex;</span><br><span class="line">        size = toIndex - fromIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在之后对子列表操作时，会先调用<code>checkForComodification</code>方法，若原CopyOnWriteArrayList被修改，则抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only call this holding l's lock</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l.getArray() != expectedArray)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此取subList时需要考虑线程安全问题，更好的方式是使用不可变列表（例如Guava的ImmutableList），避免对原始列表的更新导致子列表抛出异常，更新缓存时指向新的ImmutableList对象即可，相关代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> ImmutableList&lt;Info&gt;&gt; FULL_LIST = ImmutableList.of();</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;Info&gt; <span class="title">getList</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> FULL_LIST.subList(start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some logic</span></span><br><span class="line">    FULL_LIST = ImmutableList.copyOf(newList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImmutableList的subList方法取的的是一个子类SubList，和COWSubList类似，仅是一个视图。但由于列表不可变，仅需要检查索引未越界即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">ImmutableList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    SubList(<span class="keyword">int</span> offset, <span class="keyword">int</span> length) &#123;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此外，不可变列表无需加锁，避免了COWSubList中操作都需要获得锁的不便。测试对于有大量读线程的情况下，ImmutableList读取效率远高于COWSubList。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Review代码时发现同事写了一段加载缓存并从缓存中获取部分数据的逻辑，使用CopyOnWriteArrayList实现，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://meantobe.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>多数据源的高效归并分页排序</title>
    <link href="http://meantobe.github.io/2019/08/15/merge_and_sort/"/>
    <id>http://meantobe.github.io/2019/08/15/merge_and_sort/</id>
    <published>2019-08-15T04:50:00.000Z</published>
    <updated>2019-08-17T15:37:37.511Z</updated>
    
    <content type="html"><![CDATA[<p>我们的用户持仓接口原本很简单，从一张单独的表A中做分页查询，按时间倒序排列，接口形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/user/holding/list?userId=&#123;&#125;&amp;pageNo=&#123;&#125;&amp;rows=&#123;&#125;</span><br></pre></td></tr></table></figure><p>查询数据库时需要几个连表操作，较为复杂，不过能够满足分页查询的效率。</p><h2 id="多数据源归并分页，第一个实现（有bug）"><a href="#多数据源归并分页，第一个实现（有bug）" class="headerlink" title="多数据源归并分页，第一个实现（有bug）"></a>多数据源归并分页，第一个实现（有bug）</h2><p>产品提了一个需求，想要把另一类用户持仓放在一起展示。从表B中取出数据，排序规则相同，按时间倒序。</p><p>首先想到的方案是通过时间戳控制分页来归并数据。从A、B中各取N条数据，合并后取时间戳最大的前N条，核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Resp&gt; <span class="title">queryPagedListByLimitTime</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">int</span> rows, <span class="keyword">long</span> limitTime)</span> </span>&#123;</span><br><span class="line">    List&lt;Resp&gt; totalList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    totalList.addAll(aService.getListByLimitTime(userId, rows, limitTime));</span><br><span class="line">    totalList.addAll(bService.getListByLimitTime(userId, rows, limitTime));</span><br><span class="line">    <span class="keyword">return</span> totalList.stream()</span><br><span class="line">                    .sorted(Comparator.comparing(Resp::getCreateTime).reversed())</span><br><span class="line">                    .limit(rows)</span><br><span class="line">                    .map(<span class="comment">/* do business */</span>)</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别查询A、B服务时的SQL如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> xxx,xxx,xxx,xxx</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">WHERE</span> userId = <span class="comment">#&#123;userId&#125; AND createTime &lt; #&#123;limitTime&#125;</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="comment">#&#123;rows&#125;</span></span><br></pre></td></tr></table></figure><p>翻页时，需要传递上一页中最后一条的时间戳，第一次请求时传递当前时间戳。因此接口设计变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/user/holding/list?userId=&#123;&#125;&amp;rows=&#123;&#125;&amp;limitTime=&#123;&#125;</span><br></pre></td></tr></table></figure><p>这个实现简单而高效，但是上线后发现有丢数据的情况。因为系统有批量下单功能，导致许多持仓数据的createTime字段毫秒值都相同。而查询时传入当页的最后一条时间戳，因此下一页中按小于此时间戳查询，就丢失了跨页的数据。</p><h2 id="Redis归并排序分页，第二个实现"><a href="#Redis归并排序分页，第二个实现" class="headerlink" title="Redis归并排序分页，第二个实现"></a>Redis归并排序分页，第二个实现</h2><p>使用时间戳排序有分页的缺陷，因此接口API需要变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/user/holding/list?userId=&#123;&#125;&amp;pageNo=&#123;&#125;&amp;rows=&#123;&#125;</span><br></pre></td></tr></table></figure><p>首先查询逻辑不变，但是现在需要尽可能查出所有数据完成排序。因此将用户数据缓存到Redis的ZSET中，score是用于排序的字段（时间戳）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putUserDataIntoRedis</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</span><br><span class="line">    String userSetKey = RedisConstants.HOLDING + <span class="string">"userId:"</span> + userId;</span><br><span class="line">    List&lt;Resp&gt; totalList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    totalList.add(aService.getAllList(userId));</span><br><span class="line">    totalList.add(bService.getAllList(userId));</span><br><span class="line">    <span class="keyword">if</span> (!totalList.isEmpty()) &#123;</span><br><span class="line">          Set&lt;ZSetOperations.TypedTuple&lt;Resp&gt;&gt; sets = totalList.stream()</span><br><span class="line">                  .map(resp -&gt; (ZSetOperations.TypedTuple&lt;Resp&gt;) <span class="keyword">new</span> DefaultTypedTuple&lt;&gt;(resp, (<span class="keyword">double</span>) resp.getCreateTime()))</span><br><span class="line">                  .collect(Collectors.toSet());</span><br><span class="line">          BoundZSetOperations&lt;String, String&gt; boundZSetOperations = redisTemplate.boundZSetOps(userSetKey);</span><br><span class="line">          boundZSetOperations.add(sets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取数据时通过Redis的ZSET取数据，以实现翻页时的高效。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Resp&gt; <span class="title">queryPagedListFromRedis</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">int</span> rows, <span class="keyword">int</span> pageNo)</span> </span>&#123;</span><br><span class="line">    String userSetKey = RedisConstants.HOLDING + <span class="string">"userId:"</span> + userId;</span><br><span class="line">    BoundZSetOperations&lt;String, Resp&gt; boundZSetOperations = redisTemplate.boundZSetOps(userSetKey);</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;Resp&gt;&gt; totalRemainSet = boundZSetOperations.reverseRange(pageNo * rows, (pageNo + <span class="number">1</span>) * rows);</span><br><span class="line">    <span class="keyword">return</span> totalRemainSet.stream()</span><br><span class="line">              .map(ZSetOperations.TypedTuple::getValue)</span><br><span class="line">              .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于此时接口已经上线，因此接口设计无法变更。那么如何处理跨页的数据丢失问题？客户端表示可以每页返回超过请求的rows数量，那么我们可以考虑在一页中把下一页中相同时间戳的数据一并返回，以兼容旧版本客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取小于入参limitTime的所有数据（需要过滤掉等于limitTime的数据）</span></span><br><span class="line">Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; totalRemainSet = boundZSetOperations.reverseRangeByScoreWithScores(<span class="number">0</span>, limitTime-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Resp&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">double</span> lastTimeStamp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;Resp&gt; val : totalRemainSet) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(val.getScore() - lastTimeStamp) &gt;= <span class="number">1</span> &amp;&amp; result.size() &gt;= rows) &#123;</span><br><span class="line">        <span class="comment">// 时间戳不同，且超过每页条数，退出并返回当前数据</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 时间戳相同 或 没有超过每页条数，则加入</span></span><br><span class="line">    result.add(val.getValue());</span><br><span class="line">    lastTimeStamp = val.getScore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现存在几个问题：</p><ol><li>需要在用户首次进入时获取全量数据，效率无法保证。</li><li>数据放在缓存中，需要更新维护，增加了系统复杂度。</li><li>（对于旧客户端的兼容）破坏了接口的约定，请求传入rows=15返回却可能是rows=200。</li></ol><p>测试对于持仓较多的用户，这个方案性能过低，因此最终未能上线。</p><h2 id="覆盖索引，第三个实现"><a href="#覆盖索引，第三个实现" class="headerlink" title="覆盖索引，第三个实现"></a>覆盖索引，第三个实现</h2><p>第二个方案虽然未上线，但是思路有可取之处。总结上面两个方案可知：</p><ol><li>由于时间戳有重复，因此以limitTime做入参是不可行的，需要分页方式查询。</li><li>由于数据源不同，因此需要以相同排序条件查出后归并。但是若通过标记id等辅助分页字段方式分页，则需要增加接口字段，增加复杂度。</li><li>全量数据归并后排序就不需要辅助字段，可保持接口参数不变，但是需要高效的查询全量数据方式。</li></ol><p>由于排序时仅需要根据createTime排序，因此获取全量数据可改为仅获取id和createTime两个字段，排序后再通过id查询信息。</p><p>增加查询这两个字段的方法，结果包装为RespIds对象。数据库建立userId和createTime两个字段的索引，使得该查询可以通过覆盖索引直接返回，无须回表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, createTime</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">WHERE</span> userId = <span class="comment">#&#123;userId&#125;</span></span><br></pre></td></tr></table></figure><p>改造查询列表接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Resp&gt; <span class="title">queryPagedList</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">int</span> rows, <span class="keyword">int</span> pageNo)</span> </span>&#123;</span><br><span class="line">    List&lt;RespIds&gt; totalList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    totalList.addAll(aService.getAllIds(userId));</span><br><span class="line">    totalList.addAll(bService.getAllIds(userId));</span><br><span class="line"></span><br><span class="line">    List&lt;RespIds&gt; curPageIds = totalList.stream()</span><br><span class="line">                        .sorted(Comparator.comparing(RespIds::getCreateTime).reversed())</span><br><span class="line">                        .skip(pageNo * rows)</span><br><span class="line">                        .limit(rows)</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">    Set&lt;Long&gt; aIds = curPageIds.stream().filter(RespIds::isA)</span><br><span class="line">                        .map(RespIds::getId)</span><br><span class="line">                        .collect(Collectors.toSet());</span><br><span class="line">    Set&lt;Long&gt; bIds = curPageIds.stream().filter(RespIds::isB)</span><br><span class="line">                        .map(RespIds::getId)</span><br><span class="line">                        .collect(Collectors.toSet());</span><br><span class="line">    Map&lt;Long, Resp&gt; respSet = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (aIds.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          respSet.putAll(aService.queryDetails(req, aIds));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bIds.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          respSet.putAll(bService.queryDetails(req, bIds));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curPageIds.stream()</span><br><span class="line">                     .map(id -&gt; respSet.getOrDefault(id.getId(), <span class="keyword">null</span>))</span><br><span class="line">                     .map(<span class="comment">/* do business */</span>)</span><br><span class="line">                     .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取信息时queryDetails通过主键索引id查询，也可以保证效率。</p><p>对客户端接口参数中的limitTime改为pageNo，对于旧版本客户端limitTime稍作处理即可实现兼容。在此不赘述。</p><p>方案三上线后和方案一效率基本相同，但是避免了方案一的遗漏数据的问题。且对于单个用户具有大量数据的情况下，方案三表现优于方案一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们的用户持仓接口原本很简单，从一张单独的表A中做分页查询，按时间倒序排列，接口形式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
      
    
    </summary>
    
    
      <category term="SQL" scheme="http://meantobe.github.io/tags/SQL/"/>
    
      <category term="Redis" scheme="http://meantobe.github.io/tags/Redis/"/>
    
      <category term="API Design" scheme="http://meantobe.github.io/tags/API-Design/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat新版本Host Name Validate问题</title>
    <link href="http://meantobe.github.io/2019/05/20/tomcat/"/>
    <id>http://meantobe.github.io/2019/05/20/tomcat/</id>
    <published>2019-05-20T03:48:00.000Z</published>
    <updated>2019-08-17T15:33:40.339Z</updated>
    
    <content type="html"><![CDATA[<p>最近将一个项目由Spring Cloud Finchely.M5升级到Greenwich.SR1，在灰度环境正常，而线上则在网关层报400 Bad Request。</p><p>首先怀疑是特殊字符的问题，因为之前也遇到过这个问题。Tomcat 7.0.73中有一处改动使得带有{}|等符号的查询会返回400。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add additional checks for valid characters to the HTTP request line parsing so invalid request lines are rejected sooner.</span><br></pre></td></tr></table></figure><p>在Tomcat 7.0.76中，添加了配置项。可以配置Tomcat行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tomcat.util.http.parser.HttpParser.requestTargetAllow=</span><br></pre></td></tr></table></figure><p>之前该项目也是通过这个配置来避免400，现在为什么不行了呢？查询Tomcat文档，该配置在<a href="https://tomcat.apache.org/tomcat-8.5-doc/config/systemprops.html" target="_blank" rel="noopener">Tomcat 8</a>中已标记为deprecated，在<a href="https://tomcat.apache.org/tomcat-9.0-doc/config/systemprops.html" target="_blank" rel="noopener">Tomcat 9</a>中移除，使用<code>relaxedPathChars</code>和<code>relaxedQueryChars</code>替代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This system property is deprecated. Use the relaxedPathChars and relaxedQueryChars attributes of the Connector instead. These attributes permit a wider range of characters to be configured as valid.</span><br></pre></td></tr></table></figure><p>Spring Boot 2.0.x到2.1.x的升级中，Tomcat版本由8.5升级至9.0，因此需要配置relaxedQueryChars和relaxedPathChars。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; <span class="title">containerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedTomcatCustomizer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedTomcatCustomizer</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">TomcatServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(TomcatServletWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">        factory.addConnectorCustomizers((TomcatConnectorCustomizer) connector -&gt; &#123;</span><br><span class="line">            connector.setAttribute(<span class="string">"relaxedPathChars"</span>, <span class="string">"\"&lt;&gt;[\\]^`&#123;|&#125;"</span>);</span><br><span class="line">            connector.setAttribute(<span class="string">"relaxedQueryChars"</span>, <span class="string">"\"&lt;&gt;[\\]^`&#123;|&#125;"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但更新后依然报400。查看服务日志，找到一段异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http-nio-8080-exec-1 | INFO  | org.apache.coyote.http11.Http11Processor(175) KEY: | Error parsing HTTP request header</span><br><span class="line"> Note: further occurrences of HTTP request parsing errors will be logged at DEBUG level.</span><br><span class="line">java.lang.IllegalArgumentException: Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986</span><br><span class="line">at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:467)</span><br><span class="line">at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:294)</span><br><span class="line">at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)</span><br><span class="line">at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834)</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415)</span><br><span class="line">at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><p>似乎是请求处理有问题，开启DEBUG日志，异常如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http-nio-8080-exec-5 | DEBUG | org.apache.coyote.http11.Http11Processor(175) KEY: | The host [finance_pools] is not valid</span><br><span class="line">java.lang.IllegalArgumentException: The character [_] is never valid in a domain name.</span><br><span class="line">at org.apache.tomcat.util.http.parser.HttpParser$DomainParseState.next(HttpParser.java:926)</span><br><span class="line">at org.apache.tomcat.util.http.parser.HttpParser.readHostDomainName(HttpParser.java:822)</span><br><span class="line">at org.apache.tomcat.util.http.parser.Host.parse(Host.java:71)</span><br><span class="line">at org.apache.tomcat.util.http.parser.Host.parse(Host.java:45)</span><br><span class="line">at org.apache.coyote.AbstractProcessor.parseHost(AbstractProcessor.java:288)</span><br><span class="line">at org.apache.coyote.http11.Http11Processor.prepareRequest(Http11Processor.java:809)</span><br><span class="line">at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:384)</span><br><span class="line">at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)</span><br><span class="line">at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834)</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415)</span><br><span class="line">at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure><p>原来是Tomcat 8.5.31/9.0.5后开启强制域名验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enable strict validation of the provided host name and port for all connectors. Requests with invalid host names and/or ports will be rejected with a 400 response. (markt)</span><br></pre></td></tr></table></figure><p>而运维在nginx中配置的upstream名称为<code>finance_pools</code>，因此被tomcat拦截。</p><p>对比Spring Cloud不同版本中不同的Tomcat版本。可见升级前版本不需严格校验，升级后版本需要。因此导致400问题。</p><table><thead><tr><th>Spring Cloud版本</th><th>Spring Boot版本</th><th>Tomcat版本</th></tr></thead><tbody><tr><td>Finchley.M5</td><td>2.0.0.M7</td><td>8.5.23</td></tr><tr><td>Greenwich.SR1</td><td>2.1.3.RELEASE</td><td>9.0.16</td></tr></tbody></table><p>联系运维将upstream名称中的下划线去掉后正常。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>Tomcat 8 -&gt; 9时，需要将<code>tomcat.util.http.parser.HttpParser.requestTargetAllow</code>替换为relaxedQueryChars和relaxedPathChars配置。</li><li>Tomcat新版本中host name validate为强制校验，因此无法使用带有下划线的host name。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近将一个项目由Spring Cloud Finchely.M5升级到Greenwich.SR1，在灰度环境正常，而线上则在网关层报400 Bad Request。&lt;/p&gt;
&lt;p&gt;首先怀疑是特殊字符的问题，因为之前也遇到过这个问题。Tomcat 7.0.73中有一处改动使得
      
    
    </summary>
    
    
      <category term="Tomcat" scheme="http://meantobe.github.io/tags/Tomcat/"/>
    
      <category term="Spring Boot" scheme="http://meantobe.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
</feed>
